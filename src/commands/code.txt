use failure::Fail;
use std::collections::HashMap;
use std::str::FromStr;

#[derive(Clone, Debug, Fail)]
#[fail(display = "Invalid class type '{}'", _0)]
pub struct ClassTypeParseError(String);

/// Contains all the data for a class/job insofar as it pertains to a specific character
#[derive(Clone, Copy, Debug, Eq, PartialEq)]
pub struct ClassInfo {
    pub level: u32,
    pub current_xp: Option<u64>,
    pub max_xp: Option<u64>,
}

/// An enum over the types of classes or jobs that are available.
/// 
/// In the case of unlocking a job, the higher level one is preferred.
/// For example, after unlocking Paladin, the class type will return
/// Paladin instead of Gladiator.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub enum ClassType {
    //  Tank
    Paladin,
    Gladiator,
    Warrior,
    Marauder,
    DarkKnight,
    Gunbreaker,
    //  Healer
    WhiteMage,
    Conjurer,
    Scholar,
    Astrologian,
    //  Damage
    Monk,
    Pugilist,
    Dragoon,
    Lancer,
    Ninja,
    Rogue,
    Samurai,
    Bard,
    Archer,
    Machinist,
    Dancer,
    BlackMage,
    Thaumaturge,
    Summoner,
    Arcanist,
    RedMage,
    BlueMage,
    //  Crafting
    Carpenter,
    Blacksmith,
    Armorer,
    Goldsmith,
    Leatherworker,
    Weaver,
    Alchemist,
    Culinarian,
    //  Gathering
    Miner,
    Botanist,
    Fisher,
}

/// Takes a string from lodestone and converts it to a ClassType.
/// Can take either the full name, or its common abbreviation as
/// shown on gear and the conversion is case insensitive.
/// 
/// For example, `paladin` and `PLD` will both convert to 
/// `ClassType::Paladin`
impl FromStr for ClassType {
    type Err = ClassTypeParseError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match &*s.to_uppercase() {
            "PALADIN"       | "PLD" => Ok(ClassType::Paladin),
            "GLADIATOR"     | "GLD" => Ok(ClassType::Gladiator),
            "WARRIOR"       | "WAR" => Ok(ClassType::Warrior),
            "MARAUDER"      | "MRD" => Ok(ClassType::Marauder),
            "DARK KNIGHT"   | "DRK" => Ok(ClassType::DarkKnight),
            "GUNBREAKER"    | "GNB" => Ok(ClassType::Gunbreaker),
            "WHITE MAGE"    | "WHM" => Ok(ClassType::WhiteMage),
            "CONJURER"      | "CNJ" => Ok(ClassType::Conjurer),
            "SCHOLAR"       | "SCH" => Ok(ClassType::Scholar),
            "ASTROLOGIAN"   | "AST" => Ok(ClassType::Astrologian),
            "MONK"          | "MNK" => Ok(ClassType::Monk),
            "PUGILIST"      | "PUG" => Ok(ClassType::Pugilist),
            "DRAGOON"       | "DRG" => Ok(ClassType::Dragoon),
            "LANCER"        | "LNC" => Ok(ClassType::Lancer),
            "NINJA"         | "NIN" => Ok(ClassType::Ninja),
            "ROGUE"         | "ROG" => Ok(ClassType::Rogue),
            "SAMURAI"       | "SAM" => Ok(ClassType::Samurai),
            "BARD"          | "BRD" => Ok(ClassType::Bard),
            "ARCHER"        | "ARC" => Ok(ClassType::Archer),
            "MACHINIST"     | "MCH" => Ok(ClassType::Machinist),
            "DANCER"        | "DNC" => Ok(ClassType::Dancer),
            "BLACK MAGE"    | "BLM" => Ok(ClassType::BlackMage),
            "THAUMATURGE"   | "THM" => Ok(ClassType::Thaumaturge),
            "SUMMONER"      | "SMN" => Ok(ClassType::Summoner),
            "ARCANIST"      | "ACN" => Ok(ClassType::Arcanist),
            "RED MAGE"      | "RDM" => Ok(ClassType::RedMage),
            "BLUE MAGE" | "BLUE MAGE (LIMITED JOB)" | "BLU" => Ok(ClassType::BlueMage),
            "CARPENTER"     | "CRP" => Ok(ClassType::Carpenter),
            "BLACKSMITH"    | "BSM" => Ok(ClassType::Blacksmith),
            "ARMORER"       | "ARM" => Ok(ClassType::Armorer),
            "GOLDSMITH"     | "GSM" => Ok(ClassType::Goldsmith),
            "LEATHERWORKER" | "LTW" => Ok(ClassType::Leatherworker),
            "WEAVER"        | "WVR" => Ok(ClassType::Weaver),
            "ALCHEMIST"     | "ALC" => Ok(ClassType::Alchemist),
            "CULINARIAN"    | "CUL" => Ok(ClassType::Culinarian),
            "MINER"         | "MIN" => Ok(ClassType::Miner),
            "BOTANIST"      | "BTN" => Ok(ClassType::Botanist),
            "FISHER"        | "FSH" => Ok(ClassType::Fisher),
            x => Err(ClassTypeParseError(x.into())),
        }
    }
}

/// Holds information about a profile's level/XP in a particular class.
#[derive(Clone, Debug, Default, Eq, PartialEq)]
pub struct Classes(HashMap<ClassType, Option<ClassInfo>>);

impl Classes {
    pub fn new() -> Self {
        Classes(HashMap::new())
    }
    /// Adds or updates a given entry.
    pub fn insert(&mut self, kind: ClassType, class: Option<ClassInfo>) {
        self.0.insert(kind, class);
    }

    /// Gets a class by name, if found
    pub fn get(&self, class: ClassType) -> Option<ClassInfo> {
        *self.0.get(&class).unwrap_or(&None)
    }
}

pub mod attribute;
pub mod clan;
pub mod class;
pub mod datacenter;
pub mod gc;
pub mod gender;
pub mod language;
pub mod profile;
pub mod race;
pub mod server;
pub(crate) mod util;
use failure::{Error, Fail, ensure};
use select::document::Document;
use select::predicate::{Class, Name};

use std::str::FromStr;

use crate::model::{
    attribute::{Attribute, Attributes},
    clan::Clan,
    class::{Classes, ClassInfo, ClassType},
    gender::Gender, 
    race::Race, 
    server::Server,
    util::load_url
};

/// Represents ways in which a search over the HTML data might go wrong.
#[derive(Fail, Debug)]
pub enum SearchError {
    /// A search for a node that was required turned up empty.
    #[fail(display = "Node not found: {}", _0)]
    NodeNotFound(String),
    /// A node was found, but the data inside it was malformed.
    #[fail(display = "Invalid data found while parsing '{}'", _0)]
    InvalidData(String),
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
struct CharInfo {
    race: Race,
    clan: Clan,
    gender: Gender,
}

/// Takes a Document and a search expression, and will return
/// a `SearchError` if it is not found. Otherwise it will return
/// the found node.
macro_rules! ensure_node {
    ($doc:ident, $search:expr) => {{
        ensure_node!($doc, $search, 0)
    }};
    
    ($doc:ident, $search:expr, $nth:expr) => {{
        let node = $doc.find($search).nth($nth);
        ensure!(node.is_some(), SearchError::NodeNotFound(stringify!($search).to_string() + "(" + stringify!($nth) + ")"));
        node.unwrap()
    }};
}

/// Holds all the data for a profile retrieved via Lodestone.
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct Profile {
    /// The id associated with the profile
    pub user_id: u32,
    /// The profile's associated Free Company
    pub free_company: Option<String>,
    /// The character's in-game name.
    pub name: String,
    /// The character's nameday
    pub nameday: String,
    /// The character's guardian
    pub guardian: String,
    /// The character's city state
    pub city_state: String,
    /// Which server the character is in.
    pub server: Server,
    /// What race the character is.
    pub race: Race,
    /// One of the two clans associated with their race.
    pub clan: Clan,
    /// Character's gender.
    pub gender: Gender,
    /// Max HP.
    pub hp: u32,
    /// Max MP.
    pub mp: u32,
    /// A list of attributes and their values.
    pub attributes: Attributes,
    /// A list of classes and their corresponding levels.
    classes: Classes,
}

impl Profile {
    /// Gets a profile for a user given their lodestone user id.
    /// 
    /// If you don't have the id, it is possible to use a 
    /// `SearchBuilder` in order to find their profile directly.
    pub fn get(user_id: u32) -> Result<Self, Error> {
        let main_doc = load_url(user_id, None)?;
        let classes_doc = load_url(user_id, Some("class_job"))?;

        //  Holds the string for Race, Clan, and Gender in that order
        let char_info = Self::parse_char_info(&main_doc)?;
        let (hp, mp) = Self::parse_char_param(&main_doc)?;

        Ok(Self {
            user_id,
            free_company: Self::parse_free_company(&main_doc),
            name: Self::parse_name(&main_doc)?,
            nameday: Self::parse_nameday(&main_doc)?,
            guardian: Self::parse_guardian(&main_doc)?,
            city_state: Self::parse_city_state(&main_doc)?,
            server: Self::parse_server(&main_doc)?,
            race: char_info.race,
            clan: char_info.clan,
            gender: char_info.gender,
            hp,
            mp,
            attributes: Self::parse_attributes(&main_doc)?,
            classes: Self::parse_classes(&classes_doc)?,
        })
    }

    /// Get the level of a specific class for this profile.
    /// 
    /// This can be used to query whether or not a job is unlocked.
    /// For instance if Gladiator is below 30, then Paladin will 
    /// return None. If Paladin is unlocked, both Gladiator and
    /// Paladin will return the same level.
    pub fn level(&self, class: ClassType) -> Option<u32> {
        match self.class_info(class) {
            Some(v) => Some(v.level),
            None => None
        }
    }

    /// Gets this profile's data for a given class
    pub fn class_info(&self, class: ClassType) -> Option<ClassInfo> {
        self.classes.get(class)
    }

    /// Borrows the full map of classes, e.g. for iteration in calling code
    pub fn all_class_info(&self) -> &Classes {
        &self.classes
    }

    fn parse_free_company(doc: &Document) -> Option<String> {
        match doc.find(Class("frame__chara__title")).next() {
            Some(node) => Some(node.text()),
            None => None,
        }
    }

    fn parse_name(doc: &Document) -> Result<String, Error> {
        Ok(ensure_node!(doc, Class("frame__chara__name")).text())
    }

    fn parse_nameday(doc: &Document) -> Result<String, Error> {
        Ok(ensure_node!(doc, Class("character-block__birth")).text())
    }

    fn parse_guardian(doc: &Document) -> Result<String, Error> {
        Ok(ensure_node!(doc, Class("character-block__name"), 1).text())
    }

    fn parse_city_state(doc: &Document) -> Result<String, Error> {
        Ok(ensure_node!(doc, Class("character-block__name"), 2).text())
    }

    fn parse_server(doc: &Document) -> Result<Server, Error> {
        let text = ensure_node!(doc, Class("frame__chara__world")).text();
        let server = text.split("\u{A0}").next();

        ensure!(server.is_some(), SearchError::InvalidData("Could not find server string.".into()));

        Ok(Server::from_str(&server.unwrap())?)
    }

    fn parse_char_info(doc: &Document) -> Result<CharInfo, Error> {
        let char_block = {
            let mut block = ensure_node!(doc, Class("character-block__name")).inner_html();
            block = block.replace(" ", "_");
            block = block.replace("<br>", " ");
            block.replace("_/_", " ")
        };

        let char_info = char_block
            .split_whitespace()
            .map(|e| e.replace("_", " "))
            .map(|e| e.into())
            .collect::<Vec<String>>();

        ensure!(char_info.len() == 3 || char_info.len() == 4, SearchError::InvalidData("character block name".into()));

        //  If the length is 4, then the race is "Au Ra"
        if char_info.len() == 4 {
            Ok(CharInfo {
                race: Race::Aura,
                clan: Clan::from_str(&char_info[2])?,
                gender: Gender::from_str(&char_info[3])?,
            })
        } else {
            Ok(CharInfo {
                race: Race::from_str(&char_info[0])?,
                clan: Clan::from_str(&char_info[1])?,
                gender: Gender::from_str(&char_info[2])?,
            })
        }
    }

    fn parse_char_param(doc: &Document) -> Result<(u32, u32), Error> {
        let attr_block = ensure_node!(doc, Class("character__param"));
        let mut hp = None;
        let mut mp = None;
        for item in attr_block.find(Name("li")) {
            if item.find(Class("character__param__text__hp--en-us")).count() == 1 {
                hp = Some(ensure_node!(item, Name("span")).text().parse::<u32>()?);
            } else if item.find(Class("character__param__text__mp--en-us")).count() == 1 {
                mp = Some(ensure_node!(item, Name("span")).text().parse::<u32>()?);
            } else {
                continue
            }
        }
        ensure!(hp.is_some() && mp.is_some(), SearchError::InvalidData("character__param".into()));
        Ok((hp.unwrap(), mp.unwrap()))
    }

    fn parse_attributes(doc: &Document) -> Result<Attributes, Error> {
        let block = ensure_node!(doc, Class("character__profile__data"));
        let mut attributes = Attributes::new();
        for item in block.find(Name("tr")) {
            let name = ensure_node!(item, Name("span")).text();
            let value = Attribute{
                level: ensure_node!(item, Name("td")).text().parse::<u16>()?
            };
            attributes.insert(name, value);
        }
        Ok(attributes)
    }

    fn parse_classes(doc: &Document) -> Result<Classes, Error> {
        let mut classes = Classes::new();

        for list in doc.find(Class("character__content")).take(4) {
            for item in list.find(Name("li")) {
                let name = ensure_node!(item, Class("character__job__name")).text();
                let classinfo = match ensure_node!(item, Class("character__job__level")).text().as_str() {
                    "-" => None,
                    level => {
                        let text = ensure_node!(item, Class("character__job__exp")).text();
                        let mut parts = text.split(" / ");
                        let current_xp = parts.next();
                        ensure!(current_xp.is_some(), SearchError::InvalidData("character__job__exp".into()));
                        let max_xp = parts.next();
                        ensure!(max_xp.is_some(), SearchError::InvalidData("character__job__exp".into()));
                        Some(ClassInfo{
                            level: level.parse()?,
                            current_xp: match current_xp.unwrap() {
                                "--" => None,
                                value => Some(value.replace(",", "").parse()?)
                            },
                            max_xp: match max_xp.unwrap() {
                                "--" => None,
                                value => Some(value.replace(",", "").parse()?)
                            },
                        })
                    }
                };

                //  For classes that have multiple titles (e.g., Paladin / Gladiator), grab the first one.
                let name = name.split(" / ").next();
                ensure!(name.is_some(), SearchError::InvalidData("character__job__name".into()));
                let class = ClassType::from_str(&name.unwrap())?;

                //  If the class added was a secondary job, then associated that level
                //  with its lower level counterpart as well. This makes returning the
                //  level for a particular grouping easier at the cost of memory.
                match class {
                    ClassType::Paladin => classes.insert(ClassType::Gladiator, classinfo),
                    ClassType::Warrior => classes.insert(ClassType::Marauder, classinfo),
                    ClassType::WhiteMage => classes.insert(ClassType::Conjurer, classinfo),
                    ClassType::Monk => classes.insert(ClassType::Pugilist, classinfo),
                    ClassType::Dragoon => classes.insert(ClassType::Lancer, classinfo),
                    ClassType::Ninja => classes.insert(ClassType::Rogue, classinfo),
                    ClassType::Bard => classes.insert(ClassType::Archer, classinfo),
                    ClassType::BlackMage => classes.insert(ClassType::Thaumaturge, classinfo),
                    ClassType::Summoner => classes.insert(ClassType::Arcanist, classinfo),
                    _ => (),
                }

                classes.insert(class, classinfo);
            }
        }

        Ok(classes)
    }
}
use failure::Fail;
use std::str::FromStr;

#[derive(Clone, Debug, Fail)]
#[fail(display = "Invalid race string '{}'", _0)]
pub struct RaceParseError(String);

/// Models the races available in XIV.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub enum Race {
    Aura,
    Elezen,
    Hyur,
    Lalafell,
    Miqote,
    Roegadyn,
}

impl FromStr for Race {
    type Err = RaceParseError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match &*s.to_uppercase() {
            "AU RA" => Ok(Race::Aura),
            "ELEZEN" => Ok(Race::Elezen),
            "HYUR" => Ok(Race::Hyur),
            "LALAFELL" => Ok(Race::Lalafell),
            "MIQO'TE" => Ok(Race::Miqote),
            "ROEGADYN" => Ok(Race::Roegadyn),
            x => Err(RaceParseError(x.into())),
        }
    }
}

import { Fail } from 'failure'; does not exist in typescript so use regular error handling

current class data is present in this json example
{
    "BOZJA": {
        "LEVEL": {
            "selector": "div.character__job__list:nth-child(7) > div:nth-child(2)"
        },
        "METTLE": {
            "selector": "div.character__job__list:nth-child(7) > div:nth-child(4)",
            "regex": "(?P<Mettle>\\S+) \\/"
        },
        "NAME": {
            "selector": "div.character__job__list:nth-child(7) > div:nth-child(3)"
        }
    },
    "EUREKA": {
        "EXP": {
            "selector": "div.character__job__list:nth-child(9) > div:nth-child(4)",
            "regex": "(?P<CurrentEXP>\\S+) \\/ (?P<MaxEXP>\\S+)"
        },
        "LEVEL": {
            "selector": "div.character__job__list:nth-child(9) > div:nth-child(2)"
        },
        "NAME": {
            "selector": "div.character__job__list:nth-child(9) > div:nth-child(3)"
        }
    },
    "PALADIN": {
        "LEVEL": {
            "selector": ".character__content > div:nth-child(2) > div:nth-child(1) > ul:nth-child(2) > li:nth-child(1) > div:nth-child(2)"
        },
        "UNLOCKSTATE": {
            "selector": ".character__content > div:nth-child(2) > div:nth-child(1) > ul:nth-child(2) > li:nth-child(1) > div:nth-child(3)"
        },
        "EXP": {
            "selector": ".character__content > div:nth-child(2) > div:nth-child(1) > ul:nth-child(2) > li:nth-child(1) > div:nth-child(4)",
            "regex": "(?P<CurrentEXP>\\S+) \\/ (?P<MaxEXP>\\S+)"
        }
    },
    "WARRIOR": {
        "LEVEL": {
            "selector": ".character__content > div:nth-child(2) > div:nth-child(1) > ul:nth-child(2) > li:nth-child(2) > div:nth-child(2)"
        },
        "UNLOCKSTATE": {
            "selector": ".character__content > div:nth-child(2) > div:nth-child(1) > ul:nth-child(2) > li:nth-child(2) > div:nth-child(3)"
        },
        "EXP": {
            "selector": ".character__content > div:nth-child(2) > div:nth-child(1) > ul:nth-child(2) > li:nth-child(2) > div:nth-child(4)",
            "regex": "(?P<CurrentEXP>\\S+) \\/ (?P<MaxEXP>\\S+)"
        }
    },
    "DARKKNIGHT": {
        "LEVEL": {
            "selector": ".character__content > div:nth-child(2) > div:nth-child(1) > ul:nth-child(2) > li:nth-child(3) > div:nth-child(2)"
        },
        "UNLOCKSTATE": {
            "selector": ".character__content > div:nth-child(2) > div:nth-child(1) > ul:nth-child(2) > li:nth-child(3) > div:nth-child(3)"
        },
        "EXP": {
            "selector": ".character__content > div:nth-child(2) > div:nth-child(1) > ul:nth-child(2) > li:nth-child(3) > div:nth-child(4)",
            "regex": "(?P<CurrentEXP>\\S+) \\/ (?P<MaxEXP>\\S+)"
        }
    },
    "GUNBREAKER": {
        "LEVEL": {
            "selector": ".character__content > div:nth-child(2) > div:nth-child(1) > ul:nth-child(2) > li:nth-child(4) > div:nth-child(2)"
        },
        "UNLOCKSTATE": {
            "selector": ".character__content > div:nth-child(2) > div:nth-child(1) > ul:nth-child(2) > li:nth-child(4) > div:nth-child(3)"
        },
        "EXP": {
            "selector": ".character__content > div:nth-child(2) > div:nth-child(1) > ul:nth-child(2) > li:nth-child(4) > div:nth-child(4)",
            "regex": "(?P<CurrentEXP>\\S+) \\/ (?P<MaxEXP>\\S+)"
        }
    },
    "WHITEMAGE": {
        "LEVEL": {
            "selector": ".character__content > div:nth-child(2) > div:nth-child(2) > ul:nth-child(2) > li:nth-child(1) > div:nth-child(2)"
        },
        "UNLOCKSTATE": {
            "selector": ".character__content > div:nth-child(2) > div:nth-child(2) > ul:nth-child(2) > li:nth-child(1) > div:nth-child(3)"
        },
        "EXP": {
            "selector": ".character__content > div:nth-child(2) > div:nth-child(2) > ul:nth-child(2) > li:nth-child(1) > div:nth-child(4)",
            "regex": "(?P<CurrentEXP>\\S+) \\/ (?P<MaxEXP>\\S+)"
        }
    },
    "SCHOLAR": {
        "LEVEL": {
            "selector": ".character__content > div:nth-child(2) > div:nth-child(2) > ul:nth-child(2) > li:nth-child(2) > div:nth-child(2)"
        },
        "UNLOCKSTATE": {
            "selector": ".character__content > div:nth-child(2) > div:nth-child(2) > ul:nth-child(2) > li:nth-child(2) > div:nth-child(3)"
        },
        "EXP": {
            "selector": ".character__content > div:nth-child(2) > div:nth-child(2) > ul:nth-child(2) > li:nth-child(2) > div:nth-child(4)",
            "regex": "(?P<CurrentEXP>\\S+) \\/ (?P<MaxEXP>\\S+)"
        }
    },
    "ASTROLOGIAN": {
        "LEVEL": {
            "selector": ".character__content > div:nth-child(2) > div:nth-child(2) > ul:nth-child(2) > li:nth-child(3) > div:nth-child(2)"
        },
        "UNLOCKSTATE": {
            "selector": ".character__content > div:nth-child(2) > div:nth-child(2) > ul:nth-child(2) > li:nth-child(3) > div:nth-child(3)"
        },
        "EXP": {
            "selector": ".character__content > div:nth-child(2) > div:nth-child(2) > ul:nth-child(2) > li:nth-child(3) > div:nth-child(4)",
            "regex": "(?P<CurrentEXP>\\S+) \\/ (?P<MaxEXP>\\S+)"
        }
    },
    "SAGE": {
        "LEVEL": {
            "selector": ".character__content > div:nth-child(2) > div:nth-child(2) > ul:nth-child(2) > li:nth-child(4) > div:nth-child(2)"
        },
        "UNLOCKSTATE": {
            "selector": ".character__content > div:nth-child(2) > div:nth-child(2) > ul:nth-child(2) > li:nth-child(4) > div:nth-child(3)"
        },
        "EXP": {
            "selector": ".character__content > div:nth-child(2) > div:nth-child(2) > ul:nth-child(2) > li:nth-child(4) > div:nth-child(4)",
            "regex": "(?P<CurrentEXP>\\S+) \\/ (?P<MaxEXP>\\S+)"
        }
    },
    "MONK": {
        "LEVEL": {
            "selector": "div.clearfix:nth-child(3) > div:nth-child(1) > ul:nth-child(2) > li:nth-child(1) > div:nth-child(2)"
        },
        "UNLOCKSTATE": {
            "selector": "div.clearfix:nth-child(3) > div:nth-child(1) > ul:nth-child(2) > li:nth-child(1) > div:nth-child(3)"
        },
        "EXP": {
            "selector": "div.clearfix:nth-child(3) > div:nth-child(1) > ul:nth-child(2) > li:nth-child(1) > div:nth-child(4)",
            "regex": "(?P<CurrentEXP>\\S+) \\/ (?P<MaxEXP>\\S+)"
        }
    },
    "DRAGOON": {
        "LEVEL": {
            "selector": "div.clearfix:nth-child(3) > div:nth-child(1) > ul:nth-child(2) > li:nth-child(2) > div:nth-child(2)"
        },
        "UNLOCKSTATE": {
            "selector": "div.clearfix:nth-child(3) > div:nth-child(1) > ul:nth-child(2) > li:nth-child(2) > div:nth-child(3)"
        },
        "EXP": {
            "selector": "div.clearfix:nth-child(3) > div:nth-child(1) > ul:nth-child(2) > li:nth-child(2) > div:nth-child(4)",
            "regex": "(?P<CurrentEXP>\\S+) \\/ (?P<MaxEXP>\\S+)"
        }
    },
    "NINJA": {
        "LEVEL": {
            "selector": "div.clearfix:nth-child(3) > div:nth-child(1) > ul:nth-child(2) > li:nth-child(3) > div:nth-child(2)"
        },
        "UNLOCKSTATE": {
            "selector": "div.clearfix:nth-child(3) > div:nth-child(1) > ul:nth-child(2) > li:nth-child(3) > div:nth-child(3)"
        },
        "EXP": {
            "selector": "div.clearfix:nth-child(3) > div:nth-child(1) > ul:nth-child(2) > li:nth-child(3) > div:nth-child(4)",
            "regex": "(?P<CurrentEXP>\\S+) \\/ (?P<MaxEXP>\\S+)"
        }
    },
    "SAMURAI": {
        "LEVEL": {
            "selector": "div.clearfix:nth-child(3) > div:nth-child(1) > ul:nth-child(2) > li:nth-child(4) > div:nth-child(2)"
        },
        "UNLOCKSTATE": {
            "selector": "div.clearfix:nth-child(3) > div:nth-child(1) > ul:nth-child(2) > li:nth-child(4) > div:nth-child(3)"
        },
        "EXP": {
            "selector": "div.clearfix:nth-child(3) > div:nth-child(1) > ul:nth-child(2) > li:nth-child(4) > div:nth-child(4)",
            "regex": "(?P<CurrentEXP>\\S+) \\/ (?P<MaxEXP>\\S+)"
        }
    },
    "REAPER": {
        "LEVEL": {
            "selector": "div.clearfix:nth-child(3) > div:nth-child(1) > ul:nth-child(2) > li:nth-child(5) > div:nth-child(2)"
        },
        "UNLOCKSTATE": {
            "selector": "div.clearfix:nth-child(3) > div:nth-child(1) > ul:nth-child(2) > li:nth-child(5) > div:nth-child(3)"
        },
        "EXP": {
            "selector": "div.clearfix:nth-child(3) > div:nth-child(1) > ul:nth-child(2) > li:nth-child(5) > div:nth-child(4)",
            "regex": "(?P<CurrentEXP>\\S+) \\/ (?P<MaxEXP>\\S+)"
        }
    },
    "VIPER": {
        "LEVEL": {
            "selector": "div.clearfix:nth-child(3) > div:nth-child(1) > ul:nth-child(2) > li:nth-child(6) > div:nth-child(2)"
        },
        "UNLOCKSTATE": {
            "selector": "div.clearfix:nth-child(3) > div:nth-child(1) > ul:nth-child(2) > li:nth-child(6) > div:nth-child(3)"
        },
        "EXP": {
            "selector": "div.clearfix:nth-child(3) > div:nth-child(1) > ul:nth-child(2) > li:nth-child(6) > div:nth-child(4)",
            "regex": "(?P<CurrentEXP>\\S+) \\/ (?P<MaxEXP>\\S+)"
        }
    },
    "BARD": {
        "LEVEL": {
            "selector": "div.clearfix:nth-child(3) > div:nth-child(2) > ul:nth-child(2) > li:nth-child(1) > div:nth-child(2)"
        },
        "UNLOCKSTATE": {
            "selector": "div.clearfix:nth-child(3) > div:nth-child(2) > ul:nth-child(2) > li:nth-child(1) > div:nth-child(3)"
        },
        "EXP": {
            "selector": "div.clearfix:nth-child(3) > div:nth-child(2) > ul:nth-child(2) > li:nth-child(1) > div:nth-child(4)",
            "regex": "(?P<CurrentEXP>\\S+) \\/ (?P<MaxEXP>\\S+)"
        }
    },
    "MACHINIST": {
        "LEVEL": {
            "selector": "div.clearfix:nth-child(3) > div:nth-child(2) > ul:nth-child(2) > li:nth-child(2) > div:nth-child(2)"
        },
        "UNLOCKSTATE": {
            "selector": "div.clearfix:nth-child(3) > div:nth-child(2) > ul:nth-child(2) > li:nth-child(2) > div:nth-child(3)"
        },
        "EXP": {
            "selector": "div.clearfix:nth-child(3) > div:nth-child(2) > ul:nth-child(2) > li:nth-child(2) > div:nth-child(4)",
            "regex": "(?P<CurrentEXP>\\S+) \\/ (?P<MaxEXP>\\S+)"
        }
    },
    "DANCER": {
        "LEVEL": {
            "selector": "div.clearfix:nth-child(3) > div:nth-child(2) > ul:nth-child(2) > li:nth-child(3) > div:nth-child(2)"
        },
        "UNLOCKSTATE": {
            "selector": "div.clearfix:nth-child(3) > div:nth-child(2) > ul:nth-child(2) > li:nth-child(3) > div:nth-child(3)"
        },
        "EXP": {
            "selector": "div.clearfix:nth-child(3) > div:nth-child(2) > ul:nth-child(2) > li:nth-child(3) > div:nth-child(4)",
            "regex": "(?P<CurrentEXP>\\S+) \\/ (?P<MaxEXP>\\S+)"
        }
    },
    "BLACKMAGE": {
        "LEVEL": {
            "selector": "ul.character__job:nth-child(4) > li:nth-child(1) > div:nth-child(2)"
        },
        "UNLOCKSTATE": {
            "selector": "ul.character__job:nth-child(4) > li:nth-child(1) > div:nth-child(3)"
        },
        "EXP": {
            "selector": "ul.character__job:nth-child(4) > li:nth-child(1) > div:nth-child(4)",
            "regex": "(?P<CurrentEXP>\\S+) \\/ (?P<MaxEXP>\\S+)"
        }
    },
    "SUMMONER": {
        "LEVEL": {
            "selector": "ul.character__job:nth-child(4) > li:nth-child(2) > div:nth-child(2)"
        },
        "UNLOCKSTATE": {
            "selector": "ul.character__job:nth-child(4) > li:nth-child(2) > div:nth-child(3)"
        },
        "EXP": {
            "selector": "ul.character__job:nth-child(4) > li:nth-child(2) > div:nth-child(4)",
            "regex": "(?P<CurrentEXP>\\S+) \\/ (?P<MaxEXP>\\S+)"
        }
    },
    "REDMAGE": {
        "LEVEL": {
            "selector": "ul.character__job:nth-child(4) > li:nth-child(3) > div:nth-child(2)"
        },
        "UNLOCKSTATE": {
            "selector": "ul.character__job:nth-child(4) > li:nth-child(3) > div:nth-child(3)"
        },
        "EXP": {
            "selector": "ul.character__job:nth-child(4) > li:nth-child(3) > div:nth-child(4)",
            "regex": "(?P<CurrentEXP>\\S+) \\/ (?P<MaxEXP>\\S+)"
        }
    },
    "PICTOMANCER": {
        "LEVEL": {
            "selector": "ul.character__job:nth-child(4) > li:nth-child(4) > div:nth-child(2)"
        },
        "UNLOCKSTATE": {
            "selector": "ul.character__job:nth-child(4) > li:nth-child(4) > div:nth-child(3)"
        },
        "EXP": {
            "selector": "ul.character__job:nth-child(4) > li:nth-child(4) > div:nth-child(4)",
            "regex": "(?P<CurrentEXP>\\S+) \\/ (?P<MaxEXP>\\S+)"
        }
    },
    "BLUEMAGE": {
        "LEVEL": {
            "selector": "ul.character__job:nth-child(4) > li:nth-child(5) > div:nth-child(2)"
        },
        "UNLOCKSTATE": {
            "selector": "ul.character__job:nth-child(4) > li:nth-child(5) > div:nth-child(3)"
        },
        "EXP": {
            "selector": "ul.character__job:nth-child(4) > li:nth-child(5) > div:nth-child(4)",
            "regex": "(?P<CurrentEXP>\\S+) \\/ (?P<MaxEXP>\\S+)"
        }
    },
    "CARPENTER": {
        "LEVEL": {
            "selector": "div.clearfix:nth-child(5) > div:nth-child(1) > ul:nth-child(2) > li:nth-child(1) > div:nth-child(2)"
        },
        "UNLOCKSTATE": {
            "selector": "div.clearfix:nth-child(5) > div:nth-child(1) > ul:nth-child(2) > li:nth-child(1) > div:nth-child(3)"
        },
        "EXP": {
            "selector": "div.clearfix:nth-child(5) > div:nth-child(1) > ul:nth-child(2) > li:nth-child(1) > div:nth-child(4)",
            "regex": "(?P<CurrentEXP>\\S+) \\/ (?P<MaxEXP>\\S+)"
        }
    },
    "BLACKSMITH": {
        "LEVEL": {
            "selector": "div.clearfix:nth-child(5) > div:nth-child(1) > ul:nth-child(2) > li:nth-child(2) > div:nth-child(2)"
        },
        "UNLOCKSTATE": {
            "selector": "div.clearfix:nth-child(5) > div:nth-child(1) > ul:nth-child(2) > li:nth-child(2) > div:nth-child(3)"
        },
        "EXP": {
            "selector": "div.clearfix:nth-child(5) > div:nth-child(1) > ul:nth-child(2) > li:nth-child(2) > div:nth-child(4)",
            "regex": "(?P<CurrentEXP>\\S+) \\/ (?P<MaxEXP>\\S+)"
        }
    },
    "ARMORER": {
        "LEVEL": {
            "selector": "div.clearfix:nth-child(5) > div:nth-child(1) > ul:nth-child(2) > li:nth-child(3) > div:nth-child(2)"
        },
        "UNLOCKSTATE": {
            "selector": "div.clearfix:nth-child(5) > div:nth-child(1) > ul:nth-child(2) > li:nth-child(3) > div:nth-child(3)"
        },
        "EXP": {
            "selector": "div.clearfix:nth-child(5) > div:nth-child(1) > ul:nth-child(2) > li:nth-child(3) > div:nth-child(4)",
            "regex": "(?P<CurrentEXP>\\S+) \\/ (?P<MaxEXP>\\S+)"
        }
    },
    "GOLDSMITH": {
        "LEVEL": {
            "selector": "div.clearfix:nth-child(5) > div:nth-child(1) > ul:nth-child(2) > li:nth-child(4) > div:nth-child(2)"
        },
        "UNLOCKSTATE": {
            "selector": "div.clearfix:nth-child(5) > div:nth-child(1) > ul:nth-child(2) > li:nth-child(4) > div:nth-child(3)"
        },
        "EXP": {
            "selector": "div.clearfix:nth-child(5) > div:nth-child(1) > ul:nth-child(2) > li:nth-child(4) > div:nth-child(4)",
            "regex": "(?P<CurrentEXP>\\S+) \\/ (?P<MaxEXP>\\S+)"
        }
    },
    "LEATHERWORKER": {
        "LEVEL": {
            "selector": "div.clearfix:nth-child(5) > div:nth-child(1) > ul:nth-child(2) > li:nth-child(5) > div:nth-child(2)"
        },
        "UNLOCKSTATE": {
            "selector": "div.clearfix:nth-child(5) > div:nth-child(1) > ul:nth-child(2) > li:nth-child(5) > div:nth-child(3)"
        },
        "EXP": {
            "selector": "div.clearfix:nth-child(5) > div:nth-child(1) > ul:nth-child(2) > li:nth-child(5) > div:nth-child(4)",
            "regex": "(?P<CurrentEXP>\\S+) \\/ (?P<MaxEXP>\\S+)"
        }
    },
    "WEAVER": {
        "LEVEL": {
            "selector": "div.clearfix:nth-child(5) > div:nth-child(1) > ul:nth-child(2) > li:nth-child(6) > div:nth-child(2)"
        },
        "UNLOCKSTATE": {
            "selector": "div.clearfix:nth-child(5) > div:nth-child(1) > ul:nth-child(2) > li:nth-child(6) > div:nth-child(3)"
        },
        "EXP": {
            "selector": "div.clearfix:nth-child(5) > div:nth-child(1) > ul:nth-child(2) > li:nth-child(6) > div:nth-child(4)",
            "regex": "(?P<CurrentEXP>\\S+) \\/ (?P<MaxEXP>\\S+)"
        }
    },
    "ALCHEMIST": {
        "LEVEL": {
            "selector": "div.clearfix:nth-child(5) > div:nth-child(1) > ul:nth-child(2) > li:nth-child(7) > div:nth-child(2)"
        },
        "UNLOCKSTATE": {
            "selector": "div.clearfix:nth-child(5) > div:nth-child(1) > ul:nth-child(2) > li:nth-child(7) > div:nth-child(3)"
        },
        "EXP": {
            "selector": "div.clearfix:nth-child(5) > div:nth-child(1) > ul:nth-child(2) > li:nth-child(7) > div:nth-child(4)",
            "regex": "(?P<CurrentEXP>\\S+) \\/ (?P<MaxEXP>\\S+)"
        }
    },
    "CULINARIAN": {
        "LEVEL": {
            "selector": "div.clearfix:nth-child(5) > div:nth-child(1) > ul:nth-child(2) > li:nth-child(8) > div:nth-child(2)"
        },
        "UNLOCKSTATE": {
            "selector": "div.clearfix:nth-child(5) > div:nth-child(1) > ul:nth-child(2) > li:nth-child(8) > div:nth-child(3)"
        },
        "EXP": {
            "selector": "div.clearfix:nth-child(5) > div:nth-child(1) > ul:nth-child(2) > li:nth-child(8) > div:nth-child(4)",
            "regex": "(?P<CurrentEXP>\\S+) \\/ (?P<MaxEXP>\\S+)"
        }
    },
    "MINER": {
        "LEVEL": {
            "selector": "div.clearfix:nth-child(5) > div:nth-child(2) > ul:nth-child(2) > li:nth-child(1) > div:nth-child(2)"
        },
        "UNLOCKSTATE": {
            "selector": "div.clearfix:nth-child(5) > div:nth-child(2) > ul:nth-child(2) > li:nth-child(1) > div:nth-child(3)"
        },
        "EXP": {
            "selector": "div.clearfix:nth-child(5) > div:nth-child(2) > ul:nth-child(2) > li:nth-child(1) > div:nth-child(4)",
            "regex": "(?P<CurrentEXP>\\S+) \\/ (?P<MaxEXP>\\S+)"
        }
    },
    "BOTANIST": {
        "LEVEL": {
            "selector": "div.clearfix:nth-child(5) > div:nth-child(2) > ul:nth-child(2) > li:nth-child(2) > div:nth-child(2)"
        },
        "UNLOCKSTATE": {
            "selector": "div.clearfix:nth-child(5) > div:nth-child(2) > ul:nth-child(2) > li:nth-child(2) > div:nth-child(3)"
        },
        "EXP": {
            "selector": "div.clearfix:nth-child(5) > div:nth-child(2) > ul:nth-child(2) > li:nth-child(2) > div:nth-child(4)",
            "regex": "(?P<CurrentEXP>\\S+) \\/ (?P<MaxEXP>\\S+)"
        }
    },
    "FISHER": {
        "LEVEL": {
            "selector": "div.clearfix:nth-child(5) > div:nth-child(2) > ul:nth-child(2) > li:nth-child(3) > div:nth-child(2)"
        },
        "UNLOCKSTATE": {
            "selector": "div.clearfix:nth-child(5) > div:nth-child(2) > ul:nth-child(2) > li:nth-child(3) > div:nth-child(3)"
        },
        "EXP": {
            "selector": "div.clearfix:nth-child(5) > div:nth-child(2) > ul:nth-child(2) > li:nth-child(3) > div:nth-child(4)",
            "regex": "(?P<CurrentEXP>\\S+) \\/ (?P<MaxEXP>\\S+)"
        }
    }
}

current character things are in example below 

{
    "ACTIVE_CLASSJOB": {
        "selector": ".character__class_icon > img:nth-child(1)",
        "attribute": "src"
    },
    "ACTIVE_CLASSJOB_LEVEL": {
        "selector": ".character__class__data > p:nth-child(1)",
        "regex": "LEVEL (?P<Level>\\d*)"
    },
    "AVATAR": {
        "selector": ".frame__chara__face > img:nth-child(1)",
        "attribute": "src"
    },
    "BIO": {
        "selector": ".character__selfintroduction"
    },
    "CLASSJOB_ICONS": {
        "ROOT": {
            "selector": "li",
            "multiple": true
        },
        "ICON": {
            "selector": ".js__tooltip",
            "attribute": "src"
        }
    },
    "FREE_COMPANY": {
        "ID": {
            "selector": ".character__freecompany__name > h4:nth-child(2) > a:nth-child(1)",
            "attribute": "href",
            "regex": "/lodestone/freecompany/(?P<ID>.+)/"
        },
        "NAME": {
            "selector": ".character__freecompany__name > h4:nth-child(2) > a:nth-child(1)"
        },
        "ICON_LAYERS": {
            "BOTTOM": {
                "selector": "div.character__freecompany__crest > div > img:nth-child(1)",
                "attribute": "src"
            },
            "MIDDLE": {
                "selector": "div.character__freecompany__crest > div > img:nth-child(2)",
                "attribute": "src"
            },
            "TOP": {
                "selector": "div.character__freecompany__crest > div > img:nth-child(3)",
                "attribute": "src"
            }
        }
    },
    "GRAND_COMPANY": {
        "selector": "div.character-block:nth-child(4) > div:nth-child(2) > p:nth-child(2)",
        "regex": "(?P<Name>\\S*) \/ (?P<Rank>.*)"
    },
    "GUARDIAN_DEITY": {
        "NAME": {
            "selector": "p.character-block__name:nth-child(4)"
        },
        "ICON": {
            "selector": "#character > div.character__content.selected > div.character__profile.clearfix > div.character__profile__data > div:nth-child(1) > div > div:nth-child(2) > img",
            "attribute": "src"
        }      
    },
    "NAME": {
        "selector": "div.frame__chara__box:nth-child(2) > .frame__chara__name"
    },
    "NAMEDAY": {
        "selector": ".character-block__birth"
    },
    "PORTRAIT": {
        "selector": ".js__image_popup > img:nth-child(1)",
        "attribute": "src"
    },
    "PVP_TEAM": {
        "NAME": {
            "selector": ".character__pvpteam__name > h4:nth-child(2) > a:nth-child(1)",
            "attribute": "href",
            "regex": "/lodestone/pvpteam/(?P<ID>.+)/"
        },
        "ICON_LAYERS": {
            "BOTTOM": {
                "selector": ".character__pvpteam__crest__image img:nth-child(1)",
                "attribute": "src"
            },
            "MIDDLE": {
                "selector": ".character__pvpteam__crest__image img:nth-child(2)",
                "attribute": "src"
            },
            "TOP": {
                "selector": ".character__pvpteam__crest__image img:nth-child(3)",
                "attribute": "src"
            }
        }
    },
    "RACE_CLAN_GENDER": {
        "selector": "div.character-block:nth-child(1) > div:nth-child(2) > p:nth-child(2)",
        "regex": "(?P<Race>.*)<br\\/?>(?P<Tribe>.*) \\/ (?P<Gender>.)"
    },
    "SERVER": {
        "selector": "p.frame__chara__world",
        "regex": "(?P<World>\\w*)\\s+\\[(?P<DC>\\w*)\\]"
    },
    "TITLE": {
        "selector": ".frame__chara__title"
    },
    "TOWN": {
        "NAME": {
            "selector": "div.character-block:nth-child(3) > div:nth-child(2) > p:nth-child(2)"
        },
        "ICON": {
            "selector": "#character > div.character__content.selected > div.character__profile.clearfix > div.character__profile__data > div:nth-child(1) > div > div:nth-child(3) > img",
            "attribute": "src"
        }
    }
}